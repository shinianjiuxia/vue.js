<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Vue核心：指令+选项参数+钩子函数(生命周期)</title>
    <script src="vue.js"></script>
    <style>
        
    </style>
</head>
<body>
    <div id="app1">
        <p>Vue的选项参数</p>
        {{num}}
        {{lqq}}
        <p>{{arr[0]}}</p>
        {{num|ff}}
    </div>
    <script> 
        //全局过滤器
        Vue.filter('过滤器名称',function(value1,value2){
            return 0;
        });

        //全局自定义指令
        Vue.directive('指令名称',{
            autoFocus:{ 
         // 钩子函数，被绑定元素插入父节点时调用 (父节点存在即可调用，不必存在于 document 中)。
           inserted(el){
                el.focus() 
                console.log( 'inserted' );
             },
             
            // 只调用一次，指令第一次绑定到元素时调用，用这个钩子函数可以定义一个在绑定时执行一次的初始化动作。
              bind(){ 
                  console.log( 'bind' ); 
            }, 
            // 所在组件的 VNode 更新时调用，但是可能发生在其孩子的 VNode 更新之前。 
            // 指令的值可能发生了改变也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 
            update(){ 
                console.log( 'update' ); 
            }, 
            // 所在组件的 VNode 及其孩子的 VNode 全部更新时调用。
             componentUpdated(){
                 console.log( 'componentUpdated' );
                 }, // 只调用一次，指令与元素解绑时调用。
                 
                unbind(){
                     console.log( 'unbind' ); 
                    }
        })

        //全局组件
        Vue.component('组件名',{
            template:'<div>我是全局组件的模板</div>',
            methods:{//在VueJs中，所有的从后台获取到的数据是方法data属性中，所有的函数方法是放在methods属性中，

            },
            data(){// data属性是Vue实例的数据对象，可以绑定的是对象或者是函数。Vue实例是通过new Vue()创建的，{{ }}是Vue进行插值的语法，app是Vue的实例化对象，这里需要注意的是el绑定的是视图容器，即DOM对象，data属性绑定的是模型数据。
                return{

                }
            },
            filters:{//过滤器是一个通过输入数据，能够及时对数据进行处理并返回一个数据结果的简单函数

            },
            watch:{//监测属性的选项参数

            },
            directives:{//创建自定义指令

            },
         
        })

        var vm1 = new Vue({
            el:'#app1',  //选项参数：挂载点  作用：

            data:{      //选择参数：数据代码 作用：
                msg:'',
                arr:[1],
                obj:[],
                num:0
            },

            methods:{   //选项参数：存放函数 作用：

            },

            computed:{  //选项参数：计算属性 作用  计算属性将被混入到 Vue 实例中。所有 getter 和 setter 的 this 上下文自动地绑定为 Vue 实例。没有全局只有局部
                '计算属性名':function(){
                    return tihs.msg='我是李倩倩';
                },
                'lqq':function(){
                    return this.msg='我是李倩倩';
                }
            },

            watch:{     //选项参数：代理数据监测 作用：
                num:{
                    handler:function(newValue,oldValue){
                        this.arr[0]++;
                    }
                },
                obj:{
                    handler:function(newValue,oldValue){

                    },
                    deep:true    //深度监测
                }
            },

            filters:{   //选项参数: 局部过滤器  作用:
                '过滤器名称':function(value){        //使用过滤器 {{data|过滤器的名称}}
                    return 0;
                },
                'ff':function(){
                    return 0;
                }
            },

            directives:{  //选项参数： 局部自定义指令 作用：
                '自定义指令名称':{
                    //自定义指令的钩子函数
                    bind:function(el,obj){

                    },
                    inserted(el,obj){

                    },
                    updated:function(el,obj){
                        
                    },
                }
            },

            components:{  //选项参数: 局部组件
                '组件名':{
                    template:'<div>我是局部组件里的模板</div>',
                    data(){
                        return{

                        }
                    },
                    methods:{

                    },
                    filters:{

                    },
                    computed:{

                    },
                    directives:{

                    },
                    watch:{

                    }
                }
            },

            //钩子函数（生命周期）
            beforeCreate（创建前）//当实列被创建之前的函数 没有EL 没有DATa没有TEmplate

            created（创建后）//当实例被创建完成之后的函数 没有EL 可以对data数据做一些提前的准备如进行计算，转换等

            beforeMount(载入前)//即将挂载编译后的html到对应位置时触发的函数有DOM

            mounted（载入后）//这里就是已经将编译好的html挂载到页面完成后执行的钩子函数，形成真是的DOM。那么这里就可以发送Http请求页面初始化需要的数据

            beforeUpdate（更新前）//这里会实时监听data数据的变化，如果有更新，那么会先重新渲染虚拟DOM然后再给真实DOM补丁

            updated（更新后）//

            beforeDestroy（销毁前）,

            destroyed（销毁后）
    </script>

    <br>

    <div id="app2">
        <div>
            <p>数据双像绑定</p>
            <p>v-model=""</p>
            <p>这个指令只用于表单类标签</p>
        </div>

        <div>
            <p>事件指令</p>
            <p>v-on:事件名称="fn"   简写  @事件名称="fn"</p>
            <p>v-on:事件名称="fn(obj)"   简写  @事件名称="fn(obj)"</p>
        </div>

        <div>
            <p>事件修饰符</p>
            <p>只有 v-on 和 v-model 才有事件修饰符</p>
            <p>ASCII码</p>
        </div>

        <div>
            <p>v-if he v-else</p>
            <p>v-show</p>
        </div>

        <div>
            <p>v-for="(item,index) in/of arr"</p>

            <p>v-for="(value,key) in/of obj"</p>

            <p>v-for="str/num in/of string/number"</p>
        </div>

        <div>
            <p>v-bind:标签属性名="标签属性值"   简写      :标签属性名="标签属性值" </p>
            <p>两个特殊的标签属性 class  和 style</p>
        </div>

        <div>
            <p>Vue的动画</p>
            ①过渡动画的定义；

简单来说，就是当模块消失、出现时，会以什么样的形式消失和出现；

如果要使用过渡动画，则在标签里加入属性：

transition=”过渡动画名”

例如：
?
1
	
<div class="box" v-if="box_1" transition="mytran">1</div>

这里是mytran就是过渡动画名，他是一个类名，动画将基于这个名字而添加多个不同的扩展名（具体请参看下面）

②过渡动画绑定的事件：

【1】v-if

【2】v-show

【3】v-for（只在插入和删除时触发，可以自己写，或者使用vue-animated-list插件）；

自己写例如：
?
1
	
<div v-for="i in items" class="box" transition="mytran">{{i}}</div>

动画写法略（参照下面）

【4】动态组件；

【5】在组件的根节点上，并且被Vue实例DOM方法触发（例如：vm.$appendTo(el)）。大概就是说，把组件添加到某个根节点上去。

③CSS动画：

【1】首先，需要有transition属性，然后取得其值；

【2】其次，CSS里需要有以值为名的三个类名，分别是：

假设transition的值为mytran，则类名为

说明

.mytran-transition

动画状态，css的transition属性放在这里，他表示的类会始终存在于DOM之上；

另外这里的样式会覆盖标签的默认class提供的样式

.mytran-enter

进入时，组件从这个css状态扩展为当前css状态，这个类只存在最开始的一帧

.mytran-leave

退出时，组件从原来的css状态恢复为这个状态，这个类从退出开始时生效，在退出结束时删除。

如代码：
?
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
	
<style> 
.box { 
width: 100px; 
height: 100px; 
border: 1px solid red; 
display: inline-block; 
} 
 
/*这个定义动画情况，以及存在时的样式，这个样式会覆盖class里的样式*/
.mytran-transition { 
transition: all 0.3s ease; 
background-color: greenyellow; 
} 
 
/* .mytran-enter 定义进入的开始状态 */
/* .mytran-leave 定义离开的结束状态 */
.mytran-enter, .mytran-leave { 
height: 0; 
width: 0; 
} 
</style> 
<div id="app"> 
<button @click="change">点击随机隐藏和显示</button> 
<br/> 
<div class="box" v-if="box_1" transition="mytran">1</div> 
<div class="box" v-if="box_2" transition="mytran">2</div> 
<div class="box" v-if="box_3" transition="mytran">3</div> 
</div> 
<script> 
var vm = new Vue({ 
el: '#app', 
data: { 
box_1: true, 
box_2: true, 
box_3: true
}, 
methods: { 
change: function () { 
for (var i = 1; i < 4; i++) { 
this['box_' + i] = Math.random() > 0.5 ? true : false; 
} 
} 
} 
}) 
setInterval(vm.change, 300); 
</script>

点击会随机让3个方块隐藏或者显示；

④JavaScript钩子：

【1】简单来说，这个不影响CSS动画（依然是那三个类的变化）；

【2】这个主要用于抓取进入和离开各四个时刻，用于做某些事情；

【3】这八个时刻分别为：

进入：beforeEnter（进入之前），enter（进入动画刚开始），afterEnter（进入动画结束），enterCancelled（进入被中断）；

退出：beforeLeave（退出之前），leave（退出动画刚开始），afterLeave（退出动画结束），leaveCancelled（退出被中断）；

【4】对DOM的修改，部分情况下会恢复，例如在leave这一步修改dom的textContent属性，将在dom重新进入时恢复原状；但若在enter这一步修改，则不会恢复。

如代码：
?
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
	
Vue.transition('mytran', { 
beforeEnter: function (el) { //进入之前 
console.log("进入动画开始时间:" + new Date().getTime()); 
}, 
enter: function (el) { 
el.textContent = new Date(); 
}, 
afterEnter: function (el) { 
console.log("进入结束时间:" + new Date().getTime()); 
}, 
beforeLeave: function (el) { 
console.log("离开动画开始时间:" + new Date().getTime()); 
}, 
leave: function (el) { 
$(el).text("离开中..." + new Date()); 
}, 
afterLeave: function (el) { 
console.log("离开结束时间:" + new Date().getTime()); 
} 
})

⑤自定义过渡类名：

之所以要自定义过渡类名，是因为我们不可能要求每个css动画的样式，都是按照Vuejs标准的写法来写的（比如我们下载别人写的代码）；

注：需要在声明相关的Vue实例之前进行定义。

首先，推荐一个Vuejs官方教程推荐的动画集合：（这个不是下载链接，需要打开它去找到下载链接才能下载）

https://daneden.github.io/animate.css/

下载后，导入这个css文件，然后开始自定义动画；
?
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
	
<div id="app"> 
<button @click="change">点击随机隐藏和显示</button> 
<br/> 
<div class="box animated" v-if="box" transition="bounce">1</div> 
</div> 
<script> 
Vue.transition("bounce", { 
enterClass: 'bounceInLeft', 
leaveClass: 'bounceOutRight'
}) 
var vm = new Vue({ 
el: '#app', 
data: { 
box: true
}, 
methods: { 
change: function () { 
this.box = !this.box; 
} 
} 
}); 
</script>

解释：

【1】进行动画的标签，需要有animated这个class；

【2】enterClass和leaveClass相当于之前的xxx-enter和xxx-leave；

【3】效果是从左边闪进来，从右边闪出去。

【4】需要在声明Vue实例前设置动画，否则会无效；

⑥使用animation动画

在Vuejs中，animation动画和transition动画是不同的。

简单来说，transition动画分为三步：常驻类，进入时触发的类，退出时触发的类；只有常驻类有transition动画属性，其他两步只有css状态；

而animation动画分为两步：进入时触发的类，退出时触发的类。当然，还有xxx-transition这个类存在于dom之中（这个类可以用于设置动画原点，或者干脆不设置这个类）；

在animation动画中，进入和退出时的class类，都应该有动画效果，例如：
?
1
2
3
4
5
6
7
8
9
10
11
12
13
14
	
@keyframes fat { 
0% { 
width: 100px 
} 
50% { 
width: 200px 
} 
100% { 
width: 100px 
} 
} 
.fat-leave, .fat-enter { 
animation: fat 1s both; 
}

进入和退出时，执行的类名和transition一样，都是xxx-leave和xxx-enter这样格式的；

当然，也可以自定义类名。

示例代码：
?
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
	
<style> 
.box { 
width: 100px; 
height: 100px; 
border: 1px solid red; 
display: inline-block; 
} 
@keyframes fat { 
0% { 
width: 100px 
} 
50% { 
width: 200px 
} 
100% { 
width: 100px 
} 
} 
.fat-leave, .fat-enter { 
animation: fat 1s both; 
} 
</style> 
<div id="app"> 
<button @click="change">点击随机隐藏和显示</button> 
<br/> 
<div class="box animated" v-if="box" transition="fat">1</div> 
</div> 
<script> 
var vm = new Vue({ 
el: '#app', 
data: { 
box: true
}, 
methods: { 
change: function () { 
this.box = !this.box; 
} 
} 
}); 
</script>

效果：

消失：先变宽，再恢复，然后消失；

进入：出现，变宽，再恢复，停留；

这里偷懒共用了同一个动画效果。

⑦除此之外，还有

【1】显式声明动画类型（假如动画同时存在transition和animation，且分情况执行其中一种）；

【2】过渡流程详解（触发动画时，js钩子执行与css执行的顺序）；

【3】CSS动画（就是animation，像上面那样已经写过了，具体略）；

【4】JavaScript过渡（不是js钩子，钩子是指在某个阶段会调用某个函数，但这个钩子跟动画无关），用JavaScript来控制动画，比如jquery的animate方法；

【5】v-for使用的渐进过渡；

由于暂时用不上，所以略掉，需要查看的请打开连接：

http://cn.vuejs.org/guide/transitions.html
        </div>
    </div>
    <script>
        var vm2 = new VUe({
            el:'#app2',
            data(){

            },
            methods:{

            }
        });
    </script>

   // data三种写法：
   // 1.
  // data () {
  //   return {count: 0}
  // },
 
  // 2.
  // data: {
  //   count: 0
  // },
 
  // 3.
  //data: function() {
   // return {
     // count: 0
   // }
  //},




</body>
</html>